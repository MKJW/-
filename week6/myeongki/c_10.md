# 10장
## 시스템의 3가지 유형
- 서비스 : 일반적으로 사용자가 요청을 보내면 응답을 보내주는 방식
- 일괄 처리 시스템 : 일괄 처리 처리 시스템은 매우 큰 입력 데이터를 받아 데이터를 처리하는 작업을 수행하고 결과 데이터를 생산한다.
- 스트림 처리 시스탬 : 스트림 처리는 온라인과 오프라인 일괄 처리 사이의 어딘가에 있기 때문에 때론 준실시간 처리라 불린다. 스트림 처리는 입력 이벤트가 발생한 직후 바로 작동한다.

## 정렬 대 인메모리 집계
- 루비와 리눅스의 예제를 보여줌 : 루비는 가독성이 좋고 단 메모리를 사용(해쉬)하기에 데이터셋이 너무 큰 경우에는 사용하기 힘듬
- 리눅스는 디스크에서 정렬을 통하여 보여주기 때문에 메모리 부족 없이 손쉬ㅜㅂ게 큰 데이터셋으로 확장 가능하다. 단 디스크에서 입력 파일을 읽는 속도에서 병목이 올 수 있다.

### 유닉스 철학 : 연쇄 명령을 사용해 쉽게 로그 파일을 분석할 수 있다.
- 각 프로그램은 한 가지 일만 하도록 작성
- 모든 프로그램의 출력은 아직 알려지지 않은 다른 프로그램의 입력으로 쓰일 수 있다고 생각하라
- 소프트웨어를 빠르게 써볼 수 있게 설계하고 구축하라
- 프로그래밍 작업을 줄이려면 미숙한 도움보다는 도구를 사용해라

### 유닉스에서는 동일 입력 인터페이스를 파일로 사용!!

### 맵리듀스 작업 : 맵리듀스는 유닉스 도구와 비슷한 면이 있지만 수천 대의 장비로 분산해서 실행이 가능하다는 점에서 차이가 있다.

### 단일 맵리듀스 : 맵에서 리듀스로 맵핑하고 맵에서 작업이 끝나면 리듀스에게 열 수 있다는 신호를 주고, 리듀스는 이를 통하여 병합 과정을 처리한다. 그리고 이런 단일 맵리듀스를 다른 맵리듀스랑 연결하여 (디렉토리를 통하여) 워크플로우를 만들 수 있다.

### 파일 집합이 입력으로 주어진 맵리듀스 작업이 있다면 맵리듀스 작업은 입력 파일 전체 내용을 읽는데 데이터베이스에서 이 연산을 전체 테이블 스캔이라 부른다. 적은 수의 레크드만 읽고 싶을 때 전체 테이블 스캔을 사용한다면 색인 탐색에 비해 비용이 터무니 없이 많이 들지만 분석 질의는 대량의 레코드를 대상으로 집계 연산을 하는 것이 일반적이다. 이런 경우 입력 전체를 스캔하는 건 상당히 합리적

### 일괄 처리에서 처리량을 높이기 위해서는 가능한 한 한 장비 내에서 연산을 수행해야 한다. -> 따라서 더 좋은 방법은 사용자 데이터베이스의 사본을 가져와 사용자 활동 이벤트 로그가 저장된 분산 파일 시스템에 넣는 방법이다.

### 맵리듀스는 모든 네트워크 동신을 직접 관리하기 때문에 특정 장비가 죽는 것과 같이 부분적으로 실패가 발생하더라도 애플리케이션 코드 단에서 고민할 필요가 없다. 맵리듀스는 애플리케이션 로직에 영향이 가지 않게 실패한 테스크는 확실하게 재시도한다.

### 핫키 관리 -> 인스타 유명인 관리 -> 메타데이터 유명인을 핫키로 지정 -> 핫키 관련된 레코드를 나머지 키와는 별도 파일에 저장 -> 핫 키를 가지는 레코드는 맵 사이드 조인을 사용해 처리

### 핫키 그룹화 -> 맵리듀스 단계는 레코드를 임의 리듀서로 보낸다. 각 리듀서는 핫키 레코드의 일부를 그룹화하고 키별로 집계해 간소화한 값을 출력한다. 두 번째 맵리듀스 작업은 첫 단계 모든 리듀서에서 나온 값을 키별로 모두 결합해 하나의 값으로 만든다.

### 브로드캐스트 해시 조인
- 사용자 데이터 베이스가 메모리에 들어갈 정도로 충분히 작다면 매퍼가 시작할 때 우선 분산 파일 시스템에서 사용자 데이터베이스를 읽어서 인메모리 해시 테이블에 넣고 각 맵 테스크에 조인할 큰 입력 파일 블록 중 하나를 할당하면 된다.

### 매퍼와 리듀서 내에서 선호하는 데이터베이스 클라이언트 라이브러리를 사용해 일괄 처리 작업이 한번에 레코드 하나씩 데이터베이스 서버로 직접 요청을 보내는 것 -> 방법은 유효하지만 좋지 않음
- 네트워크 요청 리소스가 많이 듬
- 데이터베이스가 과부하 상태에 빠지기 쉽다.
- 부분적으로 완료된 작업의 결과가 외부 시스템에 드러나는 상황을 만들 수 있다.
### 일괄 처리 작업 내부에 완전히 새로운 데이터베이스를 구축해 분산 파일 시스템의 작업 출력 디렉터리에 저장하는 방법

### 하드웨어를 신뢰할 수 없기 때문이 아니라 프로세스를 임의로 종료할 수 있으면 연산 클러스터에서 자원 활용도를 높일 수 있기 때문이다.

### 맵리듀스 단점
- 맵리듀스는 생성하는 모든 선행 작업이 완료됐을 때만 시작 가능 -> 유닉스 파이프로 연결된 프로세스들은 동시에 시작되고 출력은 생산되는 즉시 소비된다. 장비들 사이에 바하가 한쪽으로 쏠리거나 변한다면 작업에는 다른 태스크보다 완료할 때까지 시간이 훨씬 긴 뒤처진 태스크가 있게 마련이다.
- 매퍼는 종종 중복된다.
- 분산 파일 시스템에서 중간 상태를 저장하는 것은 중간 상태 파일들이 여러 장비에 걸쳐 복제됐다는 의미로서 이런 임시 데이터에게는 과잉조치



### 분산 파일 시스템에 중간 상태를 모두 구체화할 때 생기는 이점은 내구성이다. 맵리듀스는 중간 상태를 모두 구체화하기 때문에 쉽게 내결함성을 확보한다.

### 아래로 전파되는 결함을 피하려면 연산자를 결정적으로 만드는 것이 좋다. -> 데이터 크기에 따라 처음부터 다시 시작할지 혹은 구체화하여 해당 지점부터 시작할지 고민할 필요가 있다.

### 맵리듀스는 반복적 속성을 고려하지 않기 때문에 반복이 들어간 알고리즘에서는 비효율적

### 그래프 알고리즘은 장비 간 통신 오버헤드가 많이 발생한다. 원본 그래프보다 중간 상태가 더 클 수도 있다.. 네트워크 상에서 메시지를 보내는 오버헤드 때문에 분산 그래프 알고리즘이 심각하게 느려질 수 있다. 단일 컴퓨터의 디스크에 넣을 수 있는 크기라면 그래프치 같은 단일 장비 그래프 처리 프레임워크를... 너무 크면 프리글..


