# 3장

## 데이터베이스를 강력하게 만드는 구조

- 로그 방식의 데이터베이스에 많은 레코드가 있으면 성능이 매우 좋지 않다. 어떤 종류의 색인이라도 대개 쓰기 속도를 느리게 만든다. 이는 데이터를 쓸 때마다 매번 색인도 갱신해야 하기 때문이다. 애플리케이션 개발자나 데이터베이스 관리자가 애플리케이션의 전형적인 질의 패턴에 대한 지식을 활용해 수동으로 색인을 선택해야 한다. 그래야 필요 이상으로 오버해드를 발생시키지 않으면서 애플리케이션에 가장 큰 이익을 안겨주는 색인을 선택할 수 있다.

### 해시 색인
- 키를 데이터 파일의 바이트 오프셋에 매핑해 인메모리 해시 맵을 유지하는 전략
- 파일이 지속적으로 추가만 한다면 결국 디스크 공간이 부족해지고 이 상황은 어떻게 피할 수 있을까? 특정 크기의 세그먼트로 로그를 나누는 방식이 좋은 해결책.
- 해시 테이블은 범위 질의에 효율적이지 않다.

### ss테이블 생성과 유지
- 쓰기 -> 멤테이블에 등록
- 멤테이블 임계값 도달시에 ss테이블로 이동
- 읽기 요청 -> 멤테이블 -> 세그먼트  -> 세그먼트 ..
- 삭제된 값을 버리는 병합과 컴팩션 과정을 백그라운드에서 수행

### 만약 데이터베이스가 고장나면 아직 디스크로 기록되지 않고 멤테이블에 있는 가장 최신 쓰기는 손실된다. 이런 문제를 피하기 위해서는 이전 절과 같이 매번 쓰기를 즉시 추가할 수 있는 분리된 로그를 디스크 상에 유지해야한다.

### LSM 트리의 기본 개념
- 백그라운드에서 연쇄적으로 ss테이블을 지속적으로 병합하는 것

### b트리
- 전통적으로 4kb 크기의 고정 크기 블록이나 페이지로 나누고 한 번에 하나의 페이지에 읽기 또는 쓰기를 한다. 각 페이지는 주소나 위치를 이용해 식별할 수 있다. 이 방식으로 하나의 페이지가 다른 페이지를 참조할 수 있다.(포인터와 비슷하지만 메모리 대신 디스크에 있음.) 최정적으로 개별 키를 포함하는 페이지에 도달함.
- 데이터베이스가 고장 상황에서 스스로 복구할 수 있게 만들려면 일반적으로 디스크 상에 쓰기 전 로그라고 하는데 데이터 구조를 추가해 b트리를 구현한다. 쓰기 전 로그는 트리 페이지에 변경된 내용을 적용하기 전에 모든 b트리의 변경사항을 기록하는 추가 전용 파일이다.

### b트리 최적화
- 키를 추약해 쓰면 공간을 절약할 수 있다. 특히 트리 내부 페이지에서 키가 키 멉위 시야의 경계 역할을 하는 데 충분한 정보만 제공하면 된다. 페이지 하나에 키를 더 많이 채우면 트리는 더 높은 분기 계수를 얻는다. 그러면 트리 깊이 수준을 낮출 수 있다.

- 리프 노드는 연속되게 배치 (질의가 정렬된 순서로 키 범위의 상단 부분을 스캔해야하는 경우 모든 페이지에 대해 디스크 찾기가 필요하지 않기 때문에 페이지 단위 배치는 비효율적)

- 트리에 포인터를 추갛나다. 예를 들어 각 리프 페이지가 양쪽 형제 페이지에 대한 참조를 가지면 상위 페이지로 다시 이동하지 않아도 순서대로 키를 스캔할 수 있다.


### b vs lsm 트리
- lsm은 보통 쓰기에서 더 빠른 반면 b 트리는 읽기에서 더 빠르다고 여긴다.(lsm은 쓰기 증폭이 작다.)

### 다차원 색인
- 일반적인 하나의 색인을 통한 db에 여러개의 컬럼을 찾는 경우 -> 경도 위도를 통한 컬럼을 찾는 경우에 너무 비효율적 -> 다중 색인을 통하여 해결하자..

### 컬럼 지향 저장소
- 모든 값을 하나의 로우에 함께 저장하지 않는 대신 각 칼럼별로 모든 값을 함께 저장한다. 각 칼럼을 개별 파일에 저장하면 질의에 사용되는 칼럼만 읽고 구분 분석하면 된다.

### 데이터 큐브와 같은 집계 값은 특정 질의에 대한 성능 향상에만 사용 -> 딸라서 대부분의 데이터 웨어하우스는 가능한 한  많은 원시 데이터를 유지하려고 노력한다.

# 4장

## 데이터 부호화 형식
- 데이터를 파일에 쓰거나 네트워크를 통해 전송하려면 스스로를 포함한 일렬의 바이트열의 형태로 부호화해야 한다. 포인터는 다른 프로세스가 이해할 수 없으므로 이 일렬의 바이트열은 보통 메모리에서 사용하는 데이터 구조와는 상당히 다르다. 따라서 두 가지 표현 사이에 일종의 전환인 필요한데 인메모리 표현에서 바이트열로의 전환을 부호화(직렬화나 마샬링이라고 함)라고 하며, 그 반대를 복호화(파싱, 역질렬화, 언마샬링이라고 함)라고 한다.

## json, xml 이진 부호화
- json은 xml 보다 덜 장황하지만 이진 형식과 비교하면 둘 다 훨씬 많은 공간을 사용한다.
- 크기는 작아지지만.. 가독성에 대한 고민이 필요

## 데이터플로 모드
- 하나의 프로세스에서 다른 프로세스로 데이터를 전달하는 방법(데이터베이스, 네트워크, 메신져)



### soap은 네트워크 api요청을 위한 xml 기반 프로토콜 : 로컬 클레스와 메서드 호출을 사용해 원격 서비스에 접근하는 코드 생성이 가능하다.