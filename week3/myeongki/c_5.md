# 5장
## 복제를 하는 이유
- 지리적으로 사용자와 가깝게 데이터를 유지해 지연 시간을 줄인다.
- 시스템의 일부에 장애가 발생해도 지속적으로 동작할 수 있게 해 가용성을 높인다.
- 읽기 질의를 제공하는 장비의 수를 확장해 읽기 처리량을 늘린다.

## 리더와 팔로워
- 읽기는 임의 복제 서버에게 요청하여 데이터를 얻을 수 있다.
- 쓰기는 오직 리저 복제 서버를 통하여 처리하고 리더 서버는 로컬에 해당 변경을 저장하고 복제 로그나 변경 스트림을 통하여 나머지 팔로우 복제 서버로 전달된다.

## 동기식 vs 비동기식 복제
- 동기식은 리더가 팔로우에게 복제를 보내고 팔로우 서버가 해당 복제를 모두 완료했다는 것을 확인 한 다음에 클라이언트에게 완료를 보내는 구조이다.
- 비동기는 팔로우의 복제가 완료된 여부를 확인하지 않고 리더에서 수행한 결과를 클라이언트에게 보낸다.
- 반동기식 방식이란 하나의 팔로우만 동기식으로 처리하고 나머지는 비동기식으로 처리하는 경우를 의미한다.
- 내구성과 처리 지연 간의 트레이드오프가 있다.

### 스냅숏이란?
- 스냅숏이란 메모리 바이트, 하드웨어, 레지스터, 상태표시기 등의 모든 내용을 포함한 메모리의 현재 상태를 저장한 것을 말하며, 시스템이 고장으로 정지했을 때 복구를 위해 주기적으로 저장되는 것을 말합니다. 데이터베이스 스냅숏은 데이터베이스의 읽기 전용 정적 뷰입니다.

## 팔로우 추가
- 리더의 데이터베이스 스냅숏을 일정 시점에 가져오고, 스냅숏을 새로운 팔로우 노드에 복사 팔라워는 리더에게 스냅숏 이후의 데이터 처리 로그 요청 -> 해당 로직이 완료 이후에는 정상적인 팔로우 역할을 수행할 수 있다.

## 팔로워 복구
- 마지막 트랜잭션을 확인하고 이후 과정을 다시 리더에게 요청하는 방식

## 리더 복구
- 리더 장애 판단 : 30초 타임아웃
- 새로운 리더 선정 : 기존 리더의 최신 정보를 갖고 있는 팔로우를 리더로 선출
- 새로운 리더를 위한 시스탬 재설정 : 새로운 리더에서 데이터 쓰기 처리가 가능하도록 설정 변경

## 구문 기반 복제
- 팔로우는 클라이언트에게 받은 구문을 직접 수행 -> 비결정적인 결과를 반환하는 경우 부수효과가 발생할 수 있다 (160 밑 5 질문..)

## 쓰기 전 로그 배송
- 팔로워가 쓰기 전 로그를 통하여 리더와 같은 데이터 상태로 만드는 방식 단점으로는 버젼이 맞지 않는 경우 이슈 발생이 생길 수 있다. -> 팔로우 부터 버젼 업

## 로우(논리적) 기반 로그 복제
- 로우 단위로 데이터 베이스 테이블에 쓰기를 기술한 레코드 열.. 이를 통하여 리더와 팔로우 버젼이 다른 경우에도 복제를 실행 할 수 있다.

## 트리거 기반 복제
- 트리거는 사용자 정의 애플리케이션 코드를 등록할 수 있게 한다. 이 애플리케이션 코드는 데이터베이스 시스템에서 데이터가 변경되면 자동으로 실행된다.
- 많은 오버해드와 버그나 제한 사항이 많지만.. 유연성 때문에 매우 유용하다.

## 단조읽기
- 수행이 완료된 서버로부터 읽기 데이터를 받고 다시 재요청 시에 쓰기가 수행이 완료되지 않은 서버로 읽기를 요청한 경우에 시간이 거꾸로 가는 현상을 볼 수 있다.
- 각 사용자 읽기가 동일한 서버에서 수행되게끔 하는 방법이 있다.

## 다중 데이터센터 운영(다중 리더 복제 사용 사례)
- 쓰기가 병목되는 현상을 막을 수 있음
- 리더와 클라이언트의 네트워크 문제 내성이 생긴다
- 데이터 센터 중단 내성이 생김

- 하지만... 쓰기 충돌이 생길 수 있다. 

## 사용자 정의 충돌 해소 로직
- 해당 코드는 쓰기나 읽기 수행 중에 실행될 수 있다.

## 리더 없는 복제

### 노드가 다운됐을 때 데이터베이스에 쓰기
- 여러 노드에 읽기와 쓰기를 동시에 요청하고 업데이트가 최신 값으로 결정

## 정족수 일광성
- n개 복제 서버가 있고 w+r>n이 되게끔 w와 r을 선택한다면 일반적으로 모든 읽기는 키의 최신 값을 반환할 것을 기대한다. 이는 쓰기를 하는 노드 셋과 읽기를 하는 노드 셋이 겹치기 때문이다. 
- 하지만 한계성이 있다.. 만족하지 못하는 경우 서로 다른 노드간의 롤백을 진행하지 않기 때문에 최신이 있을 수 도 없을 수 도 있다. 느슨한 정족수를 사용한다면 겹치지 않을 수 있다.

## 이전 발생 인과관계 파악하기
- 모든 요청에 버젼을 달아주고 해당 버젼이 없으면 해당 요청은 동시에 일어났다고 간주..

### 도티드 버젼 벡터
- 클라이언트로 데이터 전달하면 유실 위험이 줄어듬

