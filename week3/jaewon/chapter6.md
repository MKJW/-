# 6장

데이터를 파티션으로 쪼개는 작업을 **샤딩** 이라고 한다.

리더 팔로워 모델에 복제와 파티셔닝을 적용하게 되면, 각 노드는 어떤 파티션에게는 리더로, 다른 어떤 파티션에게는 팔로워로 동작하게 된다.

### 키-값 데이터 파티셔닝

핫스팟이 생기지 않도록 하기 위해서는 (skewed 되지 않도록) 레코드를 균등하게 노드에 분배해야 한다.

- 키 범위 기준 파티셔닝
파티션에 연속된 범위의 키를 할당하는 방법.
키를 정렬된 순서로 저장해서 범위 스캔이 쉬워지고, 색인을 사용해서 좀 더 효율적으로 사용할 수 있다.
하지만 특정한 접근 패턴이 핫스팟을 만들어 낼 수 있음 (특정 범위에 대한 요청이 몰릴 수 있다)
이 때는 키 값에 다른 기준이 되는 값을 추가하여 방지할 수 있다.
- 키의 해시값 기준 파티셔닝
해시 함수를 사용하는 방법.
비슷한 키 값을 해시 함수에 넣더라도, 균일하게 분산되기 때문에 위 문제를 해결할 수 있다.
이 때의 해시함수는 암호적으로 강력할 필요는 없다.
해시 값을 구한 뒤, 범위를 나눠 다시 위의 방법으로 사용하면 된다.

하지만 범위 질의를 효율적으로 할 수 있다는 장점이 사라진다.
(왜냐면 인접했던 키들이 해시 함수를 거치면서 흩어지게 되니깐)

복합 기본키를 사용해서, 키의 첫 부분에만 해싱을 적용해 파티션을 결정하고, 그 내부에서는 SS테이블에서 사용하던 방식을 그대로 써서 범위 스캔을 효율적으로 한다면, 어느정도 타협해서 사용할 수 있다.

키를 해싱하면 핫스팟을 줄일 수 있지만, 완벽히 제거할 수 없음. 항상 동일한 키를 사용하는 극단적인 상황에서는 해싱을 하더라도 부하가 나누어 지지 않는다.

현대 데이터 시스템은 크게 쏠린 작업부하를 자동으로 보정하지 못하므로, 애플리케이션 단에서 수행해야 하는데 예를 들어 요청이 매우 많이 쏠린 키를 발견하면, 키의 시작 혹은 끝에 임의의 숫자를 붙히는 것이다. 만약 십진수 2개를 붙히면 100개의 키로 분산할 수 있고, 이들은 서로 다른 파티션으로 나누어져 부하를 줄일 수 있다.

⇒ 하지만 이렇게 되면 동일 키가 100개로 나뉘는 거니깐 추후 이에 대한 작업을 수행해야 하는 단점이 생긴다.

## 보조 색인

보조 색인은 보통 레코드를 유일하게 식별하는 용도가 아닌, 특정한 값이 발생한 항목을 검색하는 수단이다.
⇒ 예를 들어 사용자 123이 실행한 액션을 모두 찾는다 와 같은 질의

보조 색인이 있는 데이터베이스를 파티셔닝 하는 방법에는 크게 두 가지가 있다.

### 문서 기준 보조 색인 파티셔닝

각 파티션에서 독립적으로 보조 색인을 관리하는 방법. **지역 색인** 이라고도 한다.

따라서 데이터베이스에 추가,삭제,갱신 등의 작업을 수행하면 해당 파티션의 보조 색인만을 다루면 된다.

하지만 색인된 컬럼의 특정 값이 하나의 파티션에 몰려있다는 보장이 없기 때문에, 색인을 통한 질의를 하고 싶다면 모든 파티션에 질의를 보낸 뒤 그 결과를 모아서 반환해줘야 한다. 이런 방식을 **scatter/gather** 라고 한다.

### 용어 기준 보조 색인 파티셔닝

모든 파티션의 데이터를 담당하는 **전역 색인** 을 만드는 방법.

하지만 하나의 노드에 색인을 저장하면 이 노드가 병목이 되므로 파티셔닝의 의미가 사라진다.
따라서 이 전역 색인 역시 파티셔닝 해서 여러 노드에 나누어 저장해야 한다.
색인의 값 혹은 그의 해시값을 사용해서 파티셔닝 하여 질의를 수행하면 된다.

이상적인 상태라면 색인은 항상 최신 상태를 유지해야 하지만, 비동기로 갱신된다.
(분산 트랜잭션을 사용해서 최신상태로 항상 유지하는 것은 비용이 많이 들기 때문..?)

### 파티션 재균형화

시간이 지나서 데이터베이스에 변화가 생기면, 데이터를 한 노드에서 다른 노드로 옮겨야 하는 과정이 필요할 수 있는데, 이를 재균형화(Rebalancing) 이라고 한다.

- 해시값에 mod N 연산으로 분배 (**사용하면 안되는 전략**)
이 방식은 N 이 변하게 되면 값이 계속 변화해서 노드 사이의 이동이 빈번하게 발생한다는 문제가 생김.
- 파티션 개수 고정
파티션을 노드 개수에 비해 많이 만들고, 각 노드에 여러 개의 파티션을 할당하는 방식.
예를 들어 노드 10개의 클러스터에 파티션을 1000개로 쪼개서 100개씩 할당한다.

새로운 노드가 클러스터에 추가되면, 노드들의 파티션 일부를 가져와서 새로운 노드에 할당하면 된다.
이렇게 되면 키를 옮길 필요가 없어진다.
- 동적 파티셔닝
파티션의 크기가 기준 값을 넘어서면 절반으로 쪼개거나, 기준 값 이하로 내려가면 하나로 합치는 방식
- 노드 비례 파티셔닝
노드당 할당되는 파티션의 개수를 고정하는 방식.
이렇게 되면 데이터 셋 크기에 비례해서 파티션의 크기가 늘어나지만, 노드가 추가되면 파티션의 크기는 줄어들게 된다.

### 요청 라우팅

클라이언트가 요청을 보낼 때, 어느 노드로 접속해야 하는 가를 어떻게 알 수 있을까?

이는 service discovery 문제의 일종이다.

1. 아무 노드에 접속하게 한다. (라운드 로빈이나 로드 밸런서를 통해)
만약 원하는 파티션이 있으면 그곳에서 처리하고, 없다면 적절한 노드로 전달해서 응답을 받는다.
2. 모든 요청을 라우팅 계층에 보낸다. 여기서 요청을 처리할 노드를 알아내어 해당 노드에 요청을 보내 응답을 받는다.
3. 클라이언트가 파티셔닝 방법과 어떤 노드에 데이터가 할당되는 지를 알고 있게 한다.

위 세가지 해법 모두 라우팅 결정을 내리는 구성요소가 노드에 할당된 파티션의 변경사항을 어떻게 아느냐에 대한 답이 있어야만 사용할 수 있다.

분산 데이터 시스템은 zookeeper 와 같은 코디네이션 시스템을 사용해서 클러스터 메타 데이터를 관리한다.
각 노드가 주키퍼에 자신을 등록하고, 주키퍼는 파티션과 노드 사이의 할당 정보를 관리한다.
이를 사용하면 위 목적을 달성할 수 있다.