# 5장

**복제**
같은 데이터의 복사본을 다른 위치에 있는 여러 노드에 유지하는 방법.

**파티셔닝**

큰 데이터베이스를 파티션이라는 작은 서브셋으로 나누고, 각 파티션을 여러 노드에 할당한다. (샤딩이라고도 한다)

### 리더와 팔로워

데이터베이스의 복사본을 저장하는 노드를 Replica 라고 한다.

복제 서버 중 하나를 리더로 지정하고, 데이터베이스에 쓰기 요청을 할 때는 리더에게 보낸다.
다른 복제 서버는 팔로워가 되어, 리더가 새로운 데이터를 기록할 때마다 복제 로그를 전달받아 리더가 처리한 것과 동일한 순서로 쓰기를 적용해 로컬 복사본을 갱신한다.

- 동기식 복제
팔로워가 리더와 일관성 있게 최신 데이터를 유지할 수 있게 한다.
하지만 팔로워가 죽으면 리더의 쓰기가 차단되는 단점이 있음.
- 비동기식 복제
리더가 잘못되는 경우, 팔로워에 복제되지 않은 쓰기가 유실되는 단점이 생김.
하지만 팔로워가 잘못되더라도 리더가 쓰기를 계속 수행할 수 있다는 장점.

### 노드 중단 처리

- 팔로워 장애
리더로부터 수신한 변경 로그를 로컬 디스크에 보관한 뒤, 재시작되더라도 마지막 트랜잭션 이후 과정을 따라가고, 이후 값도 리더에게 요청해서 따라잡을 수 있다.
- 리더 장애
팔로워 중 하나를 리더로 승격하고, 클라이언트는 새로운 리더에 쓰기를 수행해야 하며, 팔로워들도 새로운 리더를 따라야 하는 재설정 작업이 필요하다. 이 과정을 failover 라고 한다.

### 복제 로그 구현

- 구문 기반 복제
now() 와 같은 값이 구문에 포함되는 경우, 실제 값과 복제 시 값이 달라질 수 있어 일치하지 않는 문제가 생길 수 있다.
- 쓰기전 로그 배송
저장소 엔진이 쓰기를 로그에 기록하는데 이를 사용하는 방식.
어떤 바이트를 수정했는 지에 대해 자세하게 남기기 때문에 정확한 복제를 할 수 있다.
- 논리적 로그 복제
..?

### 복제 지연 문제

비동기 팔로워에서 팔로워가 뒤처진다면 이미 지난 정보를 볼 수 있는 상황이 벌어진다.
하지만 이런 불일치 상태는 일시적이고, 데이터베이스에 쓰기를 멈추고 기다리면 결국 팔로워가 따라잡아 리더와 동일한 정보를 제공하게 된다. 이런 효과를 **최종적 일관성** 이라고 한다.

1. 자신이 쓴 내용 읽기
사용자가 자신이 쓴 내용은 일관성 있게 읽을 수 있도록 하는 방식
자신이 수정한 내용을 읽을 때는 리더에서 읽도록 하는 것과 같은 방식을 사용해서 얻을 수 있다.
2. 단조 읽기
쓰기 요청이 각 팔로워에 복제되는 시간이 다르기 때문에 서로 다른 팔로워에서 값을 읽는 경우에 시간이 거꾸로 가는 것과 같은 현상이 발생할 수 있다.
3. 일관된 순서로 읽기
특정한 순서로 이루어진 요청이 서로 뒤섞인 채로 보일 수 있는데, 서로 인과성이 있는 쓰기의 경우는 동일한 파티션에 기록되도록 함으로써 방지할 수 있다..

**일관된 상태 수렴**

데이터베이스는 **수렴** 의 방식으로 충돌을 해소해야 하는데, 이는 모든 변경이 복제 되어 서버에 동일한 최종 값이 전달되도록 해야 한다는 것이다.

### 동시 쓰기 감지

클라이언트가 동시에 같은 키에 쓰기 작업을 수행하게 되어, 하나의 요청이 다른 요청의 결과를 덮어쓰게 되면 영구적으로 일관성이 깨지게 된다. 이를 해소할 수 있는 방법은 다음과 같은 것들이 있다.

1. 최종 쓰기 승리
각 복제본이 가진 예전 값을 버리고 최신 값으로 덮어쓰는 방식.
이벤트의 순서가 정해져 있지 않기 때문에 (네트워크 딜레이로 늦을 수도 있음) 어떤 것이 최신인 가에 대한 기준을 정하고 그에 맞추어 가장 최신인 값을 남기면 된다.