# 11장
## 메시징 시스템
### 발행 구독 모델에서는 여러 시스템들이 다양한 접근법을 사용한다. 아래 두 질문을 통하여 적합하게 튜닝하여 메시징 시스템을 사용할 수 있다.
- 생산자가 소비자가 메시지를 처리하는 속도보다 빠르게 전송한다면? 버리거나 or 버퍼링 하거나 or 배압(흐름제어)를 한다.
- 노드가 죽거나 일시적으로 오프라인 된다면 어떻게 될까? 지속성을 갖추려면 디스크에 기록하거나 복제본 생성을 하거나 둘 모두를 해야한다. 그렇기 때문에 비용이 들고 해당 부분을 포기해도 괜찮다면 이를 이용하여 성능을 높일 수 있다.

### 생산자에게 소비자로 메시지를 직접 전달하기
- 많은 메시지 시스템은 중간 노드를 통하지 않고 생산자와 소비자를 네트워크로 직접 통신한다.

### 메시지 브로커
- 메시지 브로커는 근본적으로 메시지 스트림를 처리하는 데 최적화된 데이터베이스의 일종이다.
### 로드 벨런싱
- 각 메시지는 소비자 중 하나로 전달된다.
### 팬아웃
- 각 메시지는 모든 소비자에게 전달된다.

### 메시지 간 인과성이 있다면 이것은 매우 중요한 문제다.

### 메시지 브로커가 메시지를 디스크에 지속성 있게 기록하더라도 메시지가 소비자에게 전달된 후 즉시 삭제한다. 브로커는 메시지를 일시적으로 보관하는 개념으로 만들어졌기 때문이다.

### 데이터베이스의 지속성 있는 저장 방법과 메시징 시스템의 지연 시간이 짧은 알림 기능을 조합할 수는 없을까? 이것이 로그 기반 메시지 브로커의 기본 아이디어다.

### 로그를 사용한 메시지 저장소
- 메시지를 처리하는 비용이 비싸고 메시지 단위로 병렬화 처리하고 싶지만 메시지 순서는 그렇게 중요하지 않다면 jms/amqp 방식의 메시지 브로커가 적절하고 처리량이 많고 메시지를 처리하는 속도가 빠르지만 순서가 중요하다면 로그 기반 접근법이 효과적

### 소비자 오프셋
- 메시지 오프셋은 단일 리더 데이터베이스 복제에서 널리 쓰는 로그 순차 번호와 상당히 유사하다.

### 디스크 공간
- 큐가 작을 때는 빠르지만 디스크에 기록하기 시작하면 매우 느려진다. -> 고정크기 버퍼링 방식임

### 디비 싱크 맞추기
- 로그 기반 메시지 브로커의 아이디어에서 CDC를 만들었다.

### 이벤트 소싱
- 변경 데이터 캡쳐와 유사하게 애플리케이션 상태 변화를 모두 변경 이벤트 로그로 저장한다. CDC와 차이점은 적용하는 추상화 레벨이 다르다는 점이다.
- 어플리케이션 수준에서 발생한 일을 반영

### 상태를 시간으로 미분하면 스트림 -> 스트림을 시간으로 적분하면 상태가 된다.
### 이벤트 소싱을 통하여 이벤트를 로그에 추가하는 것으로 쓰기와 원자적으로 수행할 수 있다.

### 불변성의 한계부터
- 삭제는 해당 데이터를 찾기 불가능하게끔 하는 문제라기보다는 찾기 어렵게 하는 문제다.
- 삭제가 어렵다..
- 잦은 삭제 변경은 불변성을 만들기 힘들다.

### 이벤트 시간 대 처리 시간을 혼동하면 좋지 않은 데이터가 만들어진다.

### 이벤트를 서보로 보낸 시간과 서버에서 이벤트를 받은 시간의 차이를 계산하여 사용자 로컬에서 발생한 이벤트 시간을 예측할 수 있다.
### 스트림의 내결함성 : 마이크로 일괄 처리와 체크포인트 사용
